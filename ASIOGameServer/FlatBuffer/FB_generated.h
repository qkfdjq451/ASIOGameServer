// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FB_FB_H_
#define FLATBUFFERS_GENERATED_FB_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace FB {

struct Vec3;

enum Color {
  Color_BLACK = 0,
  Color_RED = 1,
  Color_YELLOW = 2,
  Color_BLUE = 3,
  Color_MIN = Color_BLACK,
  Color_MAX = Color_BLUE
};

inline const Color (&EnumValuesColor())[4] {
  static const Color values[] = {
    Color_BLACK,
    Color_RED,
    Color_YELLOW,
    Color_BLUE
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[] = {
    "BLACK",
    "RED",
    "YELLOW",
    "BLUE",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesColor()[index];
}

enum CharacterType {
  CharacterType_NONE = 0,
  CharacterType_Sinbi = 1,
  CharacterType_MIN = CharacterType_NONE,
  CharacterType_MAX = CharacterType_Sinbi
};

inline const CharacterType (&EnumValuesCharacterType())[2] {
  static const CharacterType values[] = {
    CharacterType_NONE,
    CharacterType_Sinbi
  };
  return values;
}

inline const char * const *EnumNamesCharacterType() {
  static const char * const names[] = {
    "NONE",
    "Sinbi",
    nullptr
  };
  return names;
}

inline const char *EnumNameCharacterType(CharacterType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCharacterType()[index];
}

enum PlayerType {
  PlayerType_Player = 0,
  PlayerType_Monster = 1,
  PlayerType_NPC = 2,
  PlayerType_MIN = PlayerType_Player,
  PlayerType_MAX = PlayerType_NPC
};

inline const PlayerType (&EnumValuesPlayerType())[3] {
  static const PlayerType values[] = {
    PlayerType_Player,
    PlayerType_Monster,
    PlayerType_NPC
  };
  return values;
}

inline const char * const *EnumNamesPlayerType() {
  static const char * const names[] = {
    "Player",
    "Monster",
    "NPC",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlayerType(PlayerType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPlayerType()[index];
}

enum MoveState {
  MoveState_MOVING = 0,
  MoveState_STOP = 1,
  MoveState_MIN = MoveState_MOVING,
  MoveState_MAX = MoveState_STOP
};

inline const MoveState (&EnumValuesMoveState())[2] {
  static const MoveState values[] = {
    MoveState_MOVING,
    MoveState_STOP
  };
  return values;
}

inline const char * const *EnumNamesMoveState() {
  static const char * const names[] = {
    "MOVING",
    "STOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoveState(MoveState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMoveState()[index];
}

enum AttackState {
  AttackState_Combo1 = 0,
  AttackState_Combo2 = 1,
  AttackState_Combo3 = 2,
  AttackState_Skill1 = 3,
  AttackState_Skill2 = 4,
  AttackState_Skill3 = 5,
  AttackState_MIN = AttackState_Combo1,
  AttackState_MAX = AttackState_Skill3
};

inline const AttackState (&EnumValuesAttackState())[6] {
  static const AttackState values[] = {
    AttackState_Combo1,
    AttackState_Combo2,
    AttackState_Combo3,
    AttackState_Skill1,
    AttackState_Skill2,
    AttackState_Skill3
  };
  return values;
}

inline const char * const *EnumNamesAttackState() {
  static const char * const names[] = {
    "Combo1",
    "Combo2",
    "Combo3",
    "Skill1",
    "Skill2",
    "Skill3",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttackState(AttackState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAttackState()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

}  // namespace FB

#endif  // FLATBUFFERS_GENERATED_FB_FB_H_
